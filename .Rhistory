col = pal,
legend.args = list(text = 'Standard deviation (°)', side = 4, font = 2, line = 2.5, cex = 0.8),
zlim = c(0, 40))  #display the output
plot(worldline_mol,
add = TRUE,
col = adjustcolor("grey30",alpha.f=0.5)) #add background map with a semi-transparent grey colour
dev.off()
}
for(k in c(22, 62, 82, 92)){ #we start with the latitude of the -10My point (4th column)
true_time <- (k-2)*5 #for the plot title ( = ((k-2)/2)*10 )
xyz <- df[, c(1,2,k)] #select the corresponding latitude deviation
r <- rasterFromXYZ(xyz,
crs = "+proj=longlat +datum=WGS84")  #write the raster file with the UTM projection coord sys
proj_moll <- "+proj=moll +lon_0=0 +x_0=0 +y_0=0"  #mollweide projection
p <- projectRaster(r, crs = proj_moll)
pdf(paste0("C:/Users/lucas/OneDrive/Bureau/Internship_2022/figures/snapshots_sd/", true_time, "sd.pdf"), height = 7, width = 10, onefile = FALSE)
plot.new()
#
# rect(par("usr")[1], par("usr")[3],
#      par("usr")[2], par("usr")[4],
#      col = "grey92") #set light grey background
# par(new = TRUE)
par(bg = "grey92")
plot(p,
axes = FALSE,
col = pal,
legend.args = list(text = 'Standard deviation (°)', side = 4, font = 2, line = 2.5, cex = 0.8),
zlim = c(0, 60))  #display the output
plot(worldline_mol,
add = TRUE,
col = adjustcolor("grey30",alpha.f=0.5)) #add background map with a semi-transparent grey colour
dev.off()
}
for(k in c(22, 62, 82, 102)){ #we start with the latitude of the -10My point (4th column)
true_time <- (k-2)*5 #for the plot title ( = ((k-2)/2)*10 )
xyz <- df[, c(1,2,k)] #select the corresponding latitude deviation
r <- rasterFromXYZ(xyz,
crs = "+proj=longlat +datum=WGS84")  #write the raster file with the UTM projection coord sys
proj_moll <- "+proj=moll +lon_0=0 +x_0=0 +y_0=0"  #mollweide projection
p <- projectRaster(r, crs = proj_moll)
pdf(paste0("C:/Users/lucas/OneDrive/Bureau/Internship_2022/figures/snapshots_sd/", true_time, "sd.pdf"), height = 7, width = 10, onefile = FALSE)
plot.new()
#
# rect(par("usr")[1], par("usr")[3],
#      par("usr")[2], par("usr")[4],
#      col = "grey92") #set light grey background
# par(new = TRUE)
par(bg = "grey92")
plot(p,
axes = FALSE,
col = pal,
legend.args = list(text = 'Standard deviation (°)', side = 4, font = 2, line = 2.5, cex = 0.8),
zlim = c(0, 60))  #display the output
plot(worldline_mol,
add = TRUE,
col = adjustcolor("grey30",alpha.f=0.5)) #add background map with a semi-transparent grey colour
dev.off()
}
pal <- c('#f7fcb9','#d9f0a3','#addd8e','#78c679','#41ab5d','#238443','#006837','#004529') #set the palette
df <- readRDS("./data/standard_deviation_4mdls.RDS")
for(k in seq(from = 4, to = ncol(df), by = 2)){ #we start with the latitude of the -10My point (4th column)
true_time <- (k-2)*5 #for the plot title ( = ((k-2)/2)*10 )
xyz <- df[, c(1,2,k)] #select the corresponding latitude deviation
r <- rasterFromXYZ(xyz,
crs = "+proj=longlat +datum=WGS84")  #write the raster file with the UTM projection coord sys
proj_moll <- "+proj=moll +lon_0=0 +x_0=0 +y_0=0"  #mollweide projection
p <- projectRaster(r, crs = proj_moll)
if(true_time < 100){  #add a zero in front of true_time in the name of the file so that the program used to compile the plot as a GIF could sort them properely
png(paste0("./figures/standard_deviation/", 0, true_time, ".png"))
}
else{
png(paste0("./figures/standard_deviation/", true_time, ".png"))
}
plot.new()
#
# rect(par("usr")[1], par("usr")[3],
#      par("usr")[2], par("usr")[4],
#      col = "grey92") #set light grey background
# par(new = TRUE)
par(bg = "grey92")
plot(p,
axes = FALSE,
col = pal,
main = paste0("Latitude Standard Deviation between the models ", "(", true_time ,"Ma)"),
legend.args = list(text = 'Standard deviation', side = 4, font = 2, line = 2.5, cex = 0.8),
zlim = c(0, 60))  #display the output
plot(worldline_mol,
add = TRUE,
col = adjustcolor("grey30",alpha.f=0.5)) #add background map with a semi-transparent grey colour
dev.off()
}
130/5
270/5
340/5
for(k in c(14, 28, 56, 70, 84, 86, 102, 106)){ #we start with the latitude of the -10My point (4th column)
true_time <- (k-2)*5 #for the plot title ( = ((k-2)/2)*10 )
xyz <- df[, c(1,2,k)] #select the corresponding latitude deviation
r <- rasterFromXYZ(xyz,
crs = "+proj=longlat +datum=WGS84")  #write the raster file with the UTM projection coord sys
proj_moll <- "+proj=moll +lon_0=0 +x_0=0 +y_0=0"  #mollweide projection
p <- projectRaster(r, crs = proj_moll)
pdf(paste0("C:/Users/lucas/OneDrive/Bureau/Internship_2022/figures/snapshots_sd/", true_time, "_sd.pdf"), height = 7, width = 10, onefile = FALSE)
plot.new()
#
# rect(par("usr")[1], par("usr")[3],
#      par("usr")[2], par("usr")[4],
#      col = "grey92") #set light grey background
# par(new = TRUE)
par(bg = "grey92")
plot(p,
axes = FALSE,
col = pal,
legend.args = list(text = 'Standard deviation (°)', side = 4, font = 2, line = 2.5, cex = 0.8),
zlim = c(0, 60))  #display the output
plot(worldline_mol,
add = TRUE,
col = adjustcolor("grey30",alpha.f=0.5)) #add background map with a semi-transparent grey colour
dev.off()
}
## Import model's polygons as shapefiles and proceed to the georeferencing ----------------------------
source("./scripts/data_analysis/georeferencing_and_NA_pos.R") #georeferencing
source("./scripts/data_analysis/cells_to_drop.R") #spatial scaling of the ourputs of the models
MaxTime <- c("Scotese2" = 540,
"Matthews" = 410,
"Golonka" = 540, #rounded to 540 (instead of 544) for Golonka
"Seton" = 200)  #the maximum time we want to reach, we basically go as far as the model goes
assess_sd <- function(thr){
df1 <- readRDS(file = paste0("./data/extracted_paleocoordinates/", models[[1]], '.RDS')) #models list created in the "cells_to_drop.R" file
df2 <- readRDS(file = paste0("./data/extracted_paleocoordinates/", models[[2]], '.RDS'))
df3 <- readRDS(file = paste0("./data/extracted_paleocoordinates/", models[[3]], '.RDS'))
df4 <- readRDS(file = paste0("./data/extracted_paleocoordinates/", models[[4]], '.RDS'))
#spatial scaling
df1[MAX, ] = NA  #MAX returned by the "cells_to_drop.R" script
df2[MAX, ] = NA
df3[MAX, ] = NA
df4[MAX, ] = NA
#temporal scaling: we create 3 three-dimensional combinations of arrays for different time slices so we don't end up assessing sd with NAs (that returns a NA)
#we combine the 2-dimensional arrays in one 3D array (along = 3) for which we'll assess sd
comb_array4 <- abind(df1[, 1:42], df2[, 1:42], df3[, 1:42], df4[, 1:42], along = 3) #from 10 to 200Ma (4models)
comb_array3 <- abind(df1[, 43:84], df2[, 43:84], df3[, 43:84], along = 3) #from 210 to 410 (3 models: all except Seton)
comb_array2 <- abind(df1[, 85:110], df3[, 85:110], along = 3) #from 420 to 540 (2 models: Scotese and Golonka, Matthews eliminated)
#Standard deviation assessment on the 3 arrays
SD4 <- apply(comb_array4,
MARGIN = c(1,2), #on the 2 dimensions of the resulting array
FUN = sd) #we apply the sd function
SD3 <- apply(comb_array3,
MARGIN = c(1,2),
FUN = sd)
SD2 <- apply(comb_array2,
MARGIN = c(1,2),
FUN = sd)
#Values under the threshold thr eliminated from the 3 arrays
for(col in 1:(ncol(SD4)-2)){
under_thresh <- which(SD4[, col+2] <= thr) #target the elements of SD inferior to threshold
SD4[under_thresh, col] <- NA
}
for(col in 1:(ncol(SD3)-2)){
under_thresh <- which(SD3[, col+2] <= thr) #target the elements of SD inferior to threshold
SD3[under_thresh, col] <- NA
}
for(col in 1:(ncol(SD2)-2)){
under_thresh <- which(SD2[, col+2] <= thr) #target the elements of SD inferior to threshold
SD2[under_thresh, col] <- NA
}
#Arrays finally re-assembled
SD <- cbind(SD4, SD3, SD2)
return(SD)
}
thr = -1
SD <- assess_sd(thr = thr)
SD_df <- data.frame(SD)
#we get the initial coordinates of the spatial data points (as subtracting two dfs makes them = 0, which is annoying)
coords_ref <- readRDS('./data/extracted_paleocoordinates/Scotese2.RDS')[,1:2]
SD_df[, 1:2] <- coords_ref
saveRDS(SD_df, "./data/standard_deviation_4mdls_nothresh.RDS")
assess_sd <- function(){
df1 <- readRDS(file = paste0("./data/extracted_paleocoordinates/", models[[1]], '.RDS')) #models list created in the "cells_to_drop.R" file
df2 <- readRDS(file = paste0("./data/extracted_paleocoordinates/", models[[2]], '.RDS'))
df3 <- readRDS(file = paste0("./data/extracted_paleocoordinates/", models[[3]], '.RDS'))
df4 <- readRDS(file = paste0("./data/extracted_paleocoordinates/", models[[4]], '.RDS'))
#spatial scaling
df1[MAX, ] = NA  #MAX returned by the "cells_to_drop.R" script
df2[MAX, ] = NA
df3[MAX, ] = NA
df4[MAX, ] = NA
#temporal scaling: we create 3 three-dimensional combinations of arrays for different time slices so we don't end up assessing sd with NAs (that returns a NA)
#we combine the 2-dimensional arrays in one 3D array (along = 3) for which we'll assess sd
comb_array4 <- abind(df1[, 1:42], df2[, 1:42], df3[, 1:42], df4[, 1:42], along = 3) #from 10 to 200Ma (4models)
comb_array3 <- abind(df1[, 43:84], df2[, 43:84], df3[, 43:84], along = 3) #from 210 to 410 (3 models: all except Seton)
comb_array2 <- abind(df1[, 85:110], df3[, 85:110], along = 3) #from 420 to 540 (2 models: Scotese and Golonka, Matthews eliminated)
#Standard deviation assessment on the 3 arrays
SD4 <- apply(comb_array4,
MARGIN = c(1,2), #on the 2 dimensions of the resulting array
FUN = sd) #we apply the sd function
SD3 <- apply(comb_array3,
MARGIN = c(1,2),
FUN = sd)
SD2 <- apply(comb_array2,
MARGIN = c(1,2),
FUN = sd)
#Arrays finally re-assembled
SD <- cbind(SD4, SD3, SD2)
return(SD)
}
SD <- assess_sd()
SD_df <- data.frame(SD)
#we get the initial coordinates of the spatial data points (as subtracting two dfs makes them = 0, which is annoying)
coords_ref <- readRDS('./data/extracted_paleocoordinates/Scotese2.RDS')[,1:2]
SD_df[, 1:2] <- coords_ref
saveRDS(SD_df, "./data/standard_deviation_4mdls_nothresh.RDS")
## Read sd results and get rid of longitude (odd indexes) ------------------------------------
sds <- readRDS("./data/standard_deviation_4mdls_nothresh.RDS")
sds <- sds[-MAX, -c(1:2, which(seq(from = 3, to = ncol(sds)+1, by = 1) %%2 != 0))] #MAX comes from the "cell_to_drop.R" script
final_df <- data.frame(TIME = rep(x = 0, 5),
CAT = c("A: 0-5°", "B: 5-10°", "C: 10-20°", "D: 20-30°", "E: >30°"),
COUNTS = c(29500, 0, 0, 0, 0))
for(t in seq(from = 50, to = 500, by = 50)){
final_df <- rbind(final_df,
data.frame(TIME = rep(x = t, 5),
CAT = c("A: 0-5°", "B: 5-10°", "C: 10-20°", "D: 20-30°", "E: >30°"),  #the five categories we're considering
COUNTS = c(
length(which(sds[, t/10] < 5)),
length(which((sds[, t/10] < 10) & (sds[, t/10] >= 5))), #translating these categories in terms of logical condition
length(which((sds[, t/10] < 20) & (sds[, t/10] >= 10))),
length(which((sds[, t/10] < 30) & (sds[, t/10] >= 20))),
length(which(sds[, t/10] >= 30))
)
))
}
length(na.omit(sds[, 30]))
length(sds[, 30])
#raw counts
barplt <- ggplot(data = final_df, aes(fill = CAT, x = TIME, y = COUNTS)) +
geom_bar(position = "stack", #display counts
stat = "identity") +
scale_fill_viridis(discrete = T) +
scale_x_reverse() +
theme(axis.title.x = element_text(size = 18),
axis.title.y = element_text(size = 18),
axis.text = element_text(size = 15),
legend.title = element_text(size = 18),
legend.text = element_text(size = 15),
legend.key.size = unit(1, "cm"),
axis.line = element_line(colour = "black", size = 1, linetype = "solid"),
) +
labs(x = "Time (Ma)", y = "Counts", fill = "Category") +
geom_vline(xintercept = 200, col = "black") +
geom_vline(xintercept = 410, col = "black")
## import our friend ggplot ------------------------------------------------------------------
library(ggplot2)
library(viridis)
#raw counts
barplt <- ggplot(data = final_df, aes(fill = CAT, x = TIME, y = COUNTS)) +
geom_bar(position = "stack", #display counts
stat = "identity") +
scale_fill_viridis(discrete = T) +
scale_x_reverse() +
theme(axis.title.x = element_text(size = 18),
axis.title.y = element_text(size = 18),
axis.text = element_text(size = 15),
legend.title = element_text(size = 18),
legend.text = element_text(size = 15),
legend.key.size = unit(1, "cm"),
axis.line = element_line(colour = "black", size = 1, linetype = "solid"),
) +
labs(x = "Time (Ma)", y = "Counts", fill = "Category") +
geom_vline(xintercept = 200, col = "black") +
geom_vline(xintercept = 410, col = "black")
barplt #some time intervals seem to have disappearing cells that reappear aftewards. Let's do the same plot but with proportions
#raw counts
barplt <- ggplot(data = final_df, aes(fill = CAT, x = TIME, y = COUNTS)) +
geom_bar(position = "stack", #display counts
stat = "identity") +
scale_fill_viridis(discrete = T) +
scale_x_reverse() +
theme(axis.title.x = element_text(size = 18),
axis.title.y = element_text(size = 18),
axis.text = element_text(size = 15),
legend.title = element_text(size = 18),
legend.text = element_text(size = 15),
legend.key.size = unit(1, "cm"),
panel.border = element_rect(colour = "black")) +
labs(x = "Time (Ma)", y = "Counts", fill = "Category") +
geom_vline(xintercept = 200, col = "black") +
geom_vline(xintercept = 410, col = "black")
barplt #some time intervals seem to have disappearing cells that reappear aftewards. Let's do the same plot but with proportions
#raw counts
barplt <- ggplot(data = final_df, aes(fill = CAT, x = TIME, y = COUNTS)) +
geom_bar(position = "stack", #display counts
stat = "identity") +
scale_fill_viridis(discrete = T) +
scale_x_reverse() +
theme(axis.title.x = element_text(size = 18),
axis.title.y = element_text(size = 18),
axis.text = element_text(size = 15),
legend.title = element_text(size = 18),
legend.text = element_text(size = 15),
legend.key.size = unit(1, "cm"),
panel.border = element_rect(colour = "black", fill = NA)) +
labs(x = "Time (Ma)", y = "Counts", fill = "Category") +
geom_vline(xintercept = 200, col = "black") +
geom_vline(xintercept = 410, col = "black")
barplt #some time intervals seem to have disappearing cells that reappear aftewards. Let's do the same plot but with proportions
#raw counts
barplt <- ggplot(data = final_df, aes(fill = CAT, x = TIME, y = COUNTS)) +
geom_bar(position = "stack", #display counts
stat = "identity") +
scale_fill_viridis(discrete = T) +
scale_x_reverse() +
theme(axis.title.x = element_text(size = 18),
axis.title.y = element_text(size = 18),
axis.text = element_text(size = 15),
legend.title = element_text(size = 18),
legend.text = element_text(size = 15),
legend.key.size = unit(1, "cm"),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 2) #frame the plot
) +
labs(x = "Time (Ma)", y = "Counts", fill = "Category") +
geom_vline(xintercept = 200, col = "red") +
geom_vline(xintercept = 410, col = "red")
barplt #some time intervals seem to have disappearing cells that reappear aftewards. Let's do the same plot but with proportions
ggsave(filename = "./figures/barplots/barplot_counts.pdf", plot = barplt)
ggsave(filename = "./figures/barplots/barplot_counts.png", plot = barplt)
#raw counts
barplt <- ggplot(data = final_df, aes(fill = CAT, x = TIME, y = COUNTS)) +
geom_bar(position = "stack", #display counts
stat = "identity") +
scale_fill_viridis(discrete = T) +
scale_x_reverse() +
theme(axis.title.x = element_text(size = 18),
axis.title.y = element_text(size = 18),
axis.text = element_text(size = 15),
legend.title = element_text(size = 18),
legend.text = element_text(size = 15),
legend.key.size = unit(1, "cm"),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 2) #frame the plot
) +
labs(x = "Time (Ma)", y = "Counts", fill = "Category") +
geom_vline(xintercept = 200, col = "red", linetype = "dashed") +
geom_vline(xintercept = 410, col = "red", linetype = "dashed")
print(barplt)
#raw counts
barplt <- ggplot(data = final_df, aes(fill = CAT, x = TIME, y = COUNTS, width = 1)) +
geom_bar(position = "stack", #display counts
stat = "identity") +
scale_fill_viridis(discrete = T) +
scale_x_reverse() +
theme(axis.title.x = element_text(size = 18),
axis.title.y = element_text(size = 18),
axis.text = element_text(size = 15),
legend.title = element_text(size = 18),
legend.text = element_text(size = 15),
legend.key.size = unit(1, "cm"),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 2) #frame the plot
) +
labs(x = "Time (Ma)", y = "Counts", fill = "Category") +
geom_vline(xintercept = 200, col = "red", linetype = "dashed") +
geom_vline(xintercept = 410, col = "red", linetype = "dashed")
print(barplt)
#raw counts
barplt <- ggplot(data = final_df, aes(fill = CAT, x = TIME, y = COUNTS, width = 15)) +
geom_bar(position = "stack", #display counts
stat = "identity") +
scale_fill_viridis(discrete = T) +
scale_x_reverse() +
theme(axis.title.x = element_text(size = 18),
axis.title.y = element_text(size = 18),
axis.text = element_text(size = 15),
legend.title = element_text(size = 18),
legend.text = element_text(size = 15),
legend.key.size = unit(1, "cm"),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 2) #frame the plot
) +
labs(x = "Time (Ma)", y = "Counts", fill = "Category") +
geom_vline(xintercept = 200, col = "red", linetype = "dashed") +
geom_vline(xintercept = 410, col = "red", linetype = "dashed")
print(barplt)
barplt
barplt
#raw counts
barplt <- ggplot(data = final_df, aes(fill = CAT, x = TIME, y = COUNTS)) +
geom_bar(position = "stack", #display counts
stat = "identity") +
scale_fill_viridis(discrete = T) +
scale_x_reverse() +
theme(axis.title.x = element_text(size = 18),
axis.title.y = element_text(size = 18),
axis.text = element_text(size = 15),
legend.title = element_text(size = 18),
legend.text = element_text(size = 15),
legend.key.size = unit(1, "cm"),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 2) #frame the plot
) +
labs(x = "Time (Ma)", y = "Counts", fill = "Category") +
geom_vline(xintercept = 200, col = "red", linetype = "dashed") +
geom_vline(xintercept = 410, col = "red", linetype = "dashed")
print(barplt)
final_df <- data.frame(TIME = rep(x = 0, 5),
CAT = rev(c("A: 0-5°", "B: 5-10°", "C: 10-20°", "D: 20-30°", "E: >30°")),
COUNTS = c(29500, 0, 0, 0, 0))
for(t in seq(from = 50, to = 500, by = 50)){
final_df <- rbind(final_df,
data.frame(TIME = rep(x = t, 5),
CAT = rev(c("A: 0-5°", "B: 5-10°", "C: 10-20°", "D: 20-30°", "E: >30°")),  #the five categories we're considering
COUNTS = c(
length(which(sds[, t/10] < 5)),
length(which((sds[, t/10] < 10) & (sds[, t/10] >= 5))), #translating these categories in terms of logical condition
length(which((sds[, t/10] < 20) & (sds[, t/10] >= 10))),
length(which((sds[, t/10] < 30) & (sds[, t/10] >= 20))),
length(which(sds[, t/10] >= 30))
)
))
}
#raw counts
barplt <- ggplot(data = final_df, aes(fill = CAT, x = TIME, y = COUNTS)) +
geom_bar(position = "stack", #display counts
stat = "identity") +
scale_fill_viridis(discrete = T) +
scale_x_reverse() +
theme(axis.title.x = element_text(size = 18),
axis.title.y = element_text(size = 18),
axis.text = element_text(size = 15),
legend.title = element_text(size = 18),
legend.text = element_text(size = 15),
legend.key.size = unit(1, "cm"),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 2) #frame the plot
) +
labs(x = "Time (Ma)", y = "Counts", fill = "Category") +
geom_vline(xintercept = 200, col = "red", linetype = "dashed") +
geom_vline(xintercept = 410, col = "red", linetype = "dashed")
print(barplt)
final_df <- data.frame(TIME = rep(x = 0, 5),
CAT = rev(c("A: 0-5°", "B: 5-10°", "C: 10-20°", "D: 20-30°", "E: >30°")),
COUNTS = rev(c(29500, 0, 0, 0, 0)))
for(t in seq(from = 50, to = 500, by = 50)){
final_df <- rbind(final_df,
data.frame(TIME = rep(x = t, 5),
CAT = rev(c("A: 0-5°", "B: 5-10°", "C: 10-20°", "D: 20-30°", "E: >30°")),  #the five categories we're considering
COUNTS = rev(c(
length(which(sds[, t/10] < 5)),
length(which((sds[, t/10] < 10) & (sds[, t/10] >= 5))), #translating these categories in terms of logical condition
length(which((sds[, t/10] < 20) & (sds[, t/10] >= 10))),
length(which((sds[, t/10] < 30) & (sds[, t/10] >= 20))),
length(which(sds[, t/10] >= 30)))
)
))
}
#raw counts
barplt <- ggplot(data = final_df, aes(fill = CAT, x = TIME, y = COUNTS)) +
geom_bar(position = "stack", #display counts
stat = "identity") +
scale_fill_viridis(discrete = T) +
scale_x_reverse() +
theme(axis.title.x = element_text(size = 18),
axis.title.y = element_text(size = 18),
axis.text = element_text(size = 15),
legend.title = element_text(size = 18),
legend.text = element_text(size = 15),
legend.key.size = unit(1, "cm"),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 2) #frame the plot
) +
labs(x = "Time (Ma)", y = "Counts", fill = "Category") +
geom_vline(xintercept = 200, col = "red", linetype = "dashed") +
geom_vline(xintercept = 410, col = "red", linetype = "dashed")
print(barplt)
ggsave(filename = "./figures/barplots/barplot_counts.pdf", plot = barplt) #save as pdf
ggsave(filename = "./figures/barplots/barplot_counts.png", plot = barplt) #and png
ggsave(filename = "./figures/barplots/barplot_counts.pdf", plot = barplt) #save as pdf
#raw counts
barplt <- ggplot(data = final_df, aes(fill = CAT, x = TIME, y = COUNTS)) +
geom_bar(position = "stack", #display counts
stat = "identity") +
scale_fill_viridis(discrete = T) +
scale_x_reverse() +
theme(axis.title.x = element_text(size = 18),
axis.title.y = element_text(size = 18),
axis.text = element_text(size = 15),
legend.title = element_text(size = 18),
legend.text = element_text(size = 15),
legend.key.size = unit(1, "cm"),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 1) #frame the plot
) +
labs(x = "Time (Ma)", y = "Counts", fill = "Category") +
geom_vline(xintercept = 200, col = "red", linetype = "dashed") +
geom_vline(xintercept = 410, col = "red", linetype = "dashed")
print(barplt)
ggsave(filename = "./figures/barplots/barplot_counts.pdf", plot = barplt) #save as pdf
ggsave(filename = "./figures/barplots/barplot_counts.png", plot = barplt) #and png
